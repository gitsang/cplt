/**
 * Autogenerated by Thrift Compiler (0.11.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "nydbc_types.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>

namespace com { namespace yealink { namespace dbc { namespace idl {

int _kdb_exception_codeValues[] = {
  db_exception_code::E_NONE,
  db_exception_code::E_EXCEPT_START,
  db_exception_code::E_NONINTERACT_BATCH_OVER_LIMITED,
  db_exception_code::E_INTERACT_BATCH_OVER_LIMITED,
  db_exception_code::E_BATCH_AUTH_FAILED,
  db_exception_code::E_BATCH_NOT_EXIST,
  db_exception_code::E_SQL_INTERNAL_ERROR,
  db_exception_code::E_REDIS_INTERNAL_ERROR,
  db_exception_code::E_PARAMETER_ERROR,
  db_exception_code::E_REDIS_KEY_OR_FIELD_NOT_EXIST,
  db_exception_code::E_REDIS_LOCK_OWNER_NO_MATCH,
  db_exception_code::E_REDIS_LOCK_RESOURCE_IN_USE
};
const char* _kdb_exception_codeNames[] = {
  "E_NONE",
  "E_EXCEPT_START",
  "E_NONINTERACT_BATCH_OVER_LIMITED",
  "E_INTERACT_BATCH_OVER_LIMITED",
  "E_BATCH_AUTH_FAILED",
  "E_BATCH_NOT_EXIST",
  "E_SQL_INTERNAL_ERROR",
  "E_REDIS_INTERNAL_ERROR",
  "E_PARAMETER_ERROR",
  "E_REDIS_KEY_OR_FIELD_NOT_EXIST",
  "E_REDIS_LOCK_OWNER_NO_MATCH",
  "E_REDIS_LOCK_RESOURCE_IN_USE"
};
const std::map<int, const char*> _db_exception_code_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(12, _kdb_exception_codeValues, _kdb_exception_codeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const db_exception_code::type& val) {
  std::map<int, const char*>::const_iterator it = _db_exception_code_VALUES_TO_NAMES.find(val);
  if (it != _db_exception_code_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

int _ktransaction_isolation_levelValues[] = {
  transaction_isolation_level::TIL_RU,
  transaction_isolation_level::TIL_RC,
  transaction_isolation_level::TIL_RR,
  transaction_isolation_level::TIL_SI,
  transaction_isolation_level::TIL_SSI
};
const char* _ktransaction_isolation_levelNames[] = {
  "TIL_RU",
  "TIL_RC",
  "TIL_RR",
  "TIL_SI",
  "TIL_SSI"
};
const std::map<int, const char*> _transaction_isolation_level_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(5, _ktransaction_isolation_levelValues, _ktransaction_isolation_levelNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const transaction_isolation_level::type& val) {
  std::map<int, const char*>::const_iterator it = _transaction_isolation_level_VALUES_TO_NAMES.find(val);
  if (it != _transaction_isolation_level_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}


db_exception::~db_exception() throw() {
}


void db_exception::__set_code(const int32_t val) {
  this->code = val;
}

void db_exception::__set_str(const std::string& val) {
  this->str = val;
}
std::ostream& operator<<(std::ostream& out, const db_exception& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t db_exception::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->code);
          this->__isset.code = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->str);
          this->__isset.str = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t db_exception::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("db_exception");

  xfer += oprot->writeFieldBegin("code", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->code);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("str", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->str);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(db_exception &a, db_exception &b) {
  using ::std::swap;
  swap(a.code, b.code);
  swap(a.str, b.str);
  swap(a.__isset, b.__isset);
}

db_exception::db_exception(const db_exception& other0) : TException() {
  code = other0.code;
  str = other0.str;
  __isset = other0.__isset;
}
db_exception& db_exception::operator=(const db_exception& other1) {
  code = other1.code;
  str = other1.str;
  __isset = other1.__isset;
  return *this;
}
void db_exception::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "db_exception(";
  out << "code=" << to_string(code);
  out << ", " << "str=" << to_string(str);
  out << ")";
}

const char* db_exception::what() const throw() {
  try {
    std::stringstream ss;
    ss << "TException - service has thrown: " << *this;
    this->thriftTExceptionMessageHolder_ = ss.str();
    return this->thriftTExceptionMessageHolder_.c_str();
  } catch (const std::exception&) {
    return "TException - service has thrown: db_exception";
  }
}


sql_batch::~sql_batch() throw() {
}


void sql_batch::__set_k(const std::string& val) {
  this->k = val;
}

void sql_batch::__set_t(const int64_t val) {
  this->t = val;
}

void sql_batch::__set_r(const std::string& val) {
  this->r = val;
}
std::ostream& operator<<(std::ostream& out, const sql_batch& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t sql_batch::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->k);
          this->__isset.k = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->t);
          this->__isset.t = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->r);
          this->__isset.r = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t sql_batch::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("sql_batch");

  xfer += oprot->writeFieldBegin("k", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->k);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("t", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->t);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("r", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->r);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(sql_batch &a, sql_batch &b) {
  using ::std::swap;
  swap(a.k, b.k);
  swap(a.t, b.t);
  swap(a.r, b.r);
  swap(a.__isset, b.__isset);
}

sql_batch::sql_batch(const sql_batch& other2) {
  k = other2.k;
  t = other2.t;
  r = other2.r;
  __isset = other2.__isset;
}
sql_batch& sql_batch::operator=(const sql_batch& other3) {
  k = other3.k;
  t = other3.t;
  r = other3.r;
  __isset = other3.__isset;
  return *this;
}
void sql_batch::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "sql_batch(";
  out << "k=" << to_string(k);
  out << ", " << "t=" << to_string(t);
  out << ", " << "r=" << to_string(r);
  out << ")";
}


sql_batch_filter::~sql_batch_filter() throw() {
}


void sql_batch_filter::__set_interact(const bool val) {
  this->interact = val;
__isset.interact = true;
}

void sql_batch_filter::__set_til(const transaction_isolation_level::type val) {
  this->til = val;
__isset.til = true;
}
std::ostream& operator<<(std::ostream& out, const sql_batch_filter& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t sql_batch_filter::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->interact);
          this->__isset.interact = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast4;
          xfer += iprot->readI32(ecast4);
          this->til = (transaction_isolation_level::type)ecast4;
          this->__isset.til = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t sql_batch_filter::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("sql_batch_filter");

  if (this->__isset.interact) {
    xfer += oprot->writeFieldBegin("interact", ::apache::thrift::protocol::T_BOOL, 1);
    xfer += oprot->writeBool(this->interact);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.til) {
    xfer += oprot->writeFieldBegin("til", ::apache::thrift::protocol::T_I32, 2);
    xfer += oprot->writeI32((int32_t)this->til);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(sql_batch_filter &a, sql_batch_filter &b) {
  using ::std::swap;
  swap(a.interact, b.interact);
  swap(a.til, b.til);
  swap(a.__isset, b.__isset);
}

sql_batch_filter::sql_batch_filter(const sql_batch_filter& other5) {
  interact = other5.interact;
  til = other5.til;
  __isset = other5.__isset;
}
sql_batch_filter& sql_batch_filter::operator=(const sql_batch_filter& other6) {
  interact = other6.interact;
  til = other6.til;
  __isset = other6.__isset;
  return *this;
}
void sql_batch_filter::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "sql_batch_filter(";
  out << "interact="; (__isset.interact ? (out << to_string(interact)) : (out << "<null>"));
  out << ", " << "til="; (__isset.til ? (out << to_string(til)) : (out << "<null>"));
  out << ")";
}


db_lock::~db_lock() throw() {
}


void db_lock::__set_keys(const std::vector<std::string> & val) {
  this->keys = val;
}

void db_lock::__set_owner(const std::string& val) {
  this->owner = val;
}

void db_lock::__set_hold_time_mseconds(const int64_t val) {
  this->hold_time_mseconds = val;
__isset.hold_time_mseconds = true;
}

void db_lock::__set_try_time_mseconds(const int64_t val) {
  this->try_time_mseconds = val;
__isset.try_time_mseconds = true;
}

void db_lock::__set_remark(const std::string& val) {
  this->remark = val;
__isset.remark = true;
}
std::ostream& operator<<(std::ostream& out, const db_lock& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t db_lock::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->keys.clear();
            uint32_t _size7;
            ::apache::thrift::protocol::TType _etype10;
            xfer += iprot->readListBegin(_etype10, _size7);
            this->keys.resize(_size7);
            uint32_t _i11;
            for (_i11 = 0; _i11 < _size7; ++_i11)
            {
              xfer += iprot->readString(this->keys[_i11]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.keys = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->owner);
          this->__isset.owner = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->hold_time_mseconds);
          this->__isset.hold_time_mseconds = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->try_time_mseconds);
          this->__isset.try_time_mseconds = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->remark);
          this->__isset.remark = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t db_lock::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("db_lock");

  xfer += oprot->writeFieldBegin("keys", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->keys.size()));
    std::vector<std::string> ::const_iterator _iter12;
    for (_iter12 = this->keys.begin(); _iter12 != this->keys.end(); ++_iter12)
    {
      xfer += oprot->writeString((*_iter12));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("owner", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->owner);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.hold_time_mseconds) {
    xfer += oprot->writeFieldBegin("hold_time_mseconds", ::apache::thrift::protocol::T_I64, 3);
    xfer += oprot->writeI64(this->hold_time_mseconds);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.try_time_mseconds) {
    xfer += oprot->writeFieldBegin("try_time_mseconds", ::apache::thrift::protocol::T_I64, 4);
    xfer += oprot->writeI64(this->try_time_mseconds);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.remark) {
    xfer += oprot->writeFieldBegin("remark", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeString(this->remark);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(db_lock &a, db_lock &b) {
  using ::std::swap;
  swap(a.keys, b.keys);
  swap(a.owner, b.owner);
  swap(a.hold_time_mseconds, b.hold_time_mseconds);
  swap(a.try_time_mseconds, b.try_time_mseconds);
  swap(a.remark, b.remark);
  swap(a.__isset, b.__isset);
}

db_lock::db_lock(const db_lock& other13) {
  keys = other13.keys;
  owner = other13.owner;
  hold_time_mseconds = other13.hold_time_mseconds;
  try_time_mseconds = other13.try_time_mseconds;
  remark = other13.remark;
  __isset = other13.__isset;
}
db_lock& db_lock::operator=(const db_lock& other14) {
  keys = other14.keys;
  owner = other14.owner;
  hold_time_mseconds = other14.hold_time_mseconds;
  try_time_mseconds = other14.try_time_mseconds;
  remark = other14.remark;
  __isset = other14.__isset;
  return *this;
}
void db_lock::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "db_lock(";
  out << "keys=" << to_string(keys);
  out << ", " << "owner=" << to_string(owner);
  out << ", " << "hold_time_mseconds="; (__isset.hold_time_mseconds ? (out << to_string(hold_time_mseconds)) : (out << "<null>"));
  out << ", " << "try_time_mseconds="; (__isset.try_time_mseconds ? (out << to_string(try_time_mseconds)) : (out << "<null>"));
  out << ", " << "remark="; (__isset.remark ? (out << to_string(remark)) : (out << "<null>"));
  out << ")";
}


sql_query_filter::~sql_query_filter() throw() {
}


void sql_query_filter::__set_sql(const std::string& val) {
  this->sql = val;
}

void sql_query_filter::__set_batch(const sql_batch& val) {
  this->batch = val;
__isset.batch = true;
}
std::ostream& operator<<(std::ostream& out, const sql_query_filter& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t sql_query_filter::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->sql);
          this->__isset.sql = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->batch.read(iprot);
          this->__isset.batch = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t sql_query_filter::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("sql_query_filter");

  xfer += oprot->writeFieldBegin("sql", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->sql);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.batch) {
    xfer += oprot->writeFieldBegin("batch", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->batch.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(sql_query_filter &a, sql_query_filter &b) {
  using ::std::swap;
  swap(a.sql, b.sql);
  swap(a.batch, b.batch);
  swap(a.__isset, b.__isset);
}

sql_query_filter::sql_query_filter(const sql_query_filter& other15) {
  sql = other15.sql;
  batch = other15.batch;
  __isset = other15.__isset;
}
sql_query_filter& sql_query_filter::operator=(const sql_query_filter& other16) {
  sql = other16.sql;
  batch = other16.batch;
  __isset = other16.__isset;
  return *this;
}
void sql_query_filter::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "sql_query_filter(";
  out << "sql=" << to_string(sql);
  out << ", " << "batch="; (__isset.batch ? (out << to_string(batch)) : (out << "<null>"));
  out << ")";
}


sql_update_filter::~sql_update_filter() throw() {
}


void sql_update_filter::__set_sql(const std::string& val) {
  this->sql = val;
}

void sql_update_filter::__set_batch(const sql_batch& val) {
  this->batch = val;
__isset.batch = true;
}
std::ostream& operator<<(std::ostream& out, const sql_update_filter& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t sql_update_filter::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->sql);
          this->__isset.sql = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->batch.read(iprot);
          this->__isset.batch = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t sql_update_filter::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("sql_update_filter");

  xfer += oprot->writeFieldBegin("sql", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->sql);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.batch) {
    xfer += oprot->writeFieldBegin("batch", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->batch.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(sql_update_filter &a, sql_update_filter &b) {
  using ::std::swap;
  swap(a.sql, b.sql);
  swap(a.batch, b.batch);
  swap(a.__isset, b.__isset);
}

sql_update_filter::sql_update_filter(const sql_update_filter& other17) {
  sql = other17.sql;
  batch = other17.batch;
  __isset = other17.__isset;
}
sql_update_filter& sql_update_filter::operator=(const sql_update_filter& other18) {
  sql = other18.sql;
  batch = other18.batch;
  __isset = other18.__isset;
  return *this;
}
void sql_update_filter::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "sql_update_filter(";
  out << "sql=" << to_string(sql);
  out << ", " << "batch="; (__isset.batch ? (out << to_string(batch)) : (out << "<null>"));
  out << ")";
}


sql_update_return::~sql_update_return() throw() {
}


void sql_update_return::__set_cols(const std::vector<std::string> & val) {
  this->cols = val;
}

void sql_update_return::__set_rows(const std::vector<std::vector<std::string> > & val) {
  this->rows = val;
__isset.rows = true;
}
std::ostream& operator<<(std::ostream& out, const sql_update_return& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t sql_update_return::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->cols.clear();
            uint32_t _size19;
            ::apache::thrift::protocol::TType _etype22;
            xfer += iprot->readListBegin(_etype22, _size19);
            this->cols.resize(_size19);
            uint32_t _i23;
            for (_i23 = 0; _i23 < _size19; ++_i23)
            {
              xfer += iprot->readString(this->cols[_i23]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.cols = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->rows.clear();
            uint32_t _size24;
            ::apache::thrift::protocol::TType _etype27;
            xfer += iprot->readListBegin(_etype27, _size24);
            this->rows.resize(_size24);
            uint32_t _i28;
            for (_i28 = 0; _i28 < _size24; ++_i28)
            {
              {
                this->rows[_i28].clear();
                uint32_t _size29;
                ::apache::thrift::protocol::TType _etype32;
                xfer += iprot->readListBegin(_etype32, _size29);
                this->rows[_i28].resize(_size29);
                uint32_t _i33;
                for (_i33 = 0; _i33 < _size29; ++_i33)
                {
                  xfer += iprot->readBinary(this->rows[_i28][_i33]);
                }
                xfer += iprot->readListEnd();
              }
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.rows = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t sql_update_return::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("sql_update_return");

  xfer += oprot->writeFieldBegin("cols", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->cols.size()));
    std::vector<std::string> ::const_iterator _iter34;
    for (_iter34 = this->cols.begin(); _iter34 != this->cols.end(); ++_iter34)
    {
      xfer += oprot->writeString((*_iter34));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.rows) {
    xfer += oprot->writeFieldBegin("rows", ::apache::thrift::protocol::T_LIST, 2);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_LIST, static_cast<uint32_t>(this->rows.size()));
      std::vector<std::vector<std::string> > ::const_iterator _iter35;
      for (_iter35 = this->rows.begin(); _iter35 != this->rows.end(); ++_iter35)
      {
        {
          xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>((*_iter35).size()));
          std::vector<std::string> ::const_iterator _iter36;
          for (_iter36 = (*_iter35).begin(); _iter36 != (*_iter35).end(); ++_iter36)
          {
            xfer += oprot->writeBinary((*_iter36));
          }
          xfer += oprot->writeListEnd();
        }
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(sql_update_return &a, sql_update_return &b) {
  using ::std::swap;
  swap(a.cols, b.cols);
  swap(a.rows, b.rows);
  swap(a.__isset, b.__isset);
}

sql_update_return::sql_update_return(const sql_update_return& other37) {
  cols = other37.cols;
  rows = other37.rows;
  __isset = other37.__isset;
}
sql_update_return& sql_update_return::operator=(const sql_update_return& other38) {
  cols = other38.cols;
  rows = other38.rows;
  __isset = other38.__isset;
  return *this;
}
void sql_update_return::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "sql_update_return(";
  out << "cols=" << to_string(cols);
  out << ", " << "rows="; (__isset.rows ? (out << to_string(rows)) : (out << "<null>"));
  out << ")";
}


redis_del_filter::~redis_del_filter() throw() {
}


void redis_del_filter::__set_keys(const std::vector<std::string> & val) {
  this->keys = val;
}
std::ostream& operator<<(std::ostream& out, const redis_del_filter& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t redis_del_filter::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->keys.clear();
            uint32_t _size39;
            ::apache::thrift::protocol::TType _etype42;
            xfer += iprot->readListBegin(_etype42, _size39);
            this->keys.resize(_size39);
            uint32_t _i43;
            for (_i43 = 0; _i43 < _size39; ++_i43)
            {
              xfer += iprot->readString(this->keys[_i43]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.keys = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t redis_del_filter::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("redis_del_filter");

  xfer += oprot->writeFieldBegin("keys", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->keys.size()));
    std::vector<std::string> ::const_iterator _iter44;
    for (_iter44 = this->keys.begin(); _iter44 != this->keys.end(); ++_iter44)
    {
      xfer += oprot->writeString((*_iter44));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(redis_del_filter &a, redis_del_filter &b) {
  using ::std::swap;
  swap(a.keys, b.keys);
  swap(a.__isset, b.__isset);
}

redis_del_filter::redis_del_filter(const redis_del_filter& other45) {
  keys = other45.keys;
  __isset = other45.__isset;
}
redis_del_filter& redis_del_filter::operator=(const redis_del_filter& other46) {
  keys = other46.keys;
  __isset = other46.__isset;
  return *this;
}
void redis_del_filter::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "redis_del_filter(";
  out << "keys=" << to_string(keys);
  out << ")";
}


redis_set_filter::~redis_set_filter() throw() {
}


void redis_set_filter::__set_key(const std::string& val) {
  this->key = val;
}

void redis_set_filter::__set_value(const std::string& val) {
  this->value = val;
}

void redis_set_filter::__set_hold_time_mseconds(const int64_t val) {
  this->hold_time_mseconds = val;
__isset.hold_time_mseconds = true;
}

void redis_set_filter::__set_set_if_not_exist(const bool val) {
  this->set_if_not_exist = val;
__isset.set_if_not_exist = true;
}
std::ostream& operator<<(std::ostream& out, const redis_set_filter& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t redis_set_filter::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->key);
          this->__isset.key = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->value);
          this->__isset.value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->hold_time_mseconds);
          this->__isset.hold_time_mseconds = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->set_if_not_exist);
          this->__isset.set_if_not_exist = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t redis_set_filter::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("redis_set_filter");

  xfer += oprot->writeFieldBegin("key", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->key);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("value", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeBinary(this->value);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.hold_time_mseconds) {
    xfer += oprot->writeFieldBegin("hold_time_mseconds", ::apache::thrift::protocol::T_I64, 3);
    xfer += oprot->writeI64(this->hold_time_mseconds);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.set_if_not_exist) {
    xfer += oprot->writeFieldBegin("set_if_not_exist", ::apache::thrift::protocol::T_BOOL, 4);
    xfer += oprot->writeBool(this->set_if_not_exist);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(redis_set_filter &a, redis_set_filter &b) {
  using ::std::swap;
  swap(a.key, b.key);
  swap(a.value, b.value);
  swap(a.hold_time_mseconds, b.hold_time_mseconds);
  swap(a.set_if_not_exist, b.set_if_not_exist);
  swap(a.__isset, b.__isset);
}

redis_set_filter::redis_set_filter(const redis_set_filter& other47) {
  key = other47.key;
  value = other47.value;
  hold_time_mseconds = other47.hold_time_mseconds;
  set_if_not_exist = other47.set_if_not_exist;
  __isset = other47.__isset;
}
redis_set_filter& redis_set_filter::operator=(const redis_set_filter& other48) {
  key = other48.key;
  value = other48.value;
  hold_time_mseconds = other48.hold_time_mseconds;
  set_if_not_exist = other48.set_if_not_exist;
  __isset = other48.__isset;
  return *this;
}
void redis_set_filter::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "redis_set_filter(";
  out << "key=" << to_string(key);
  out << ", " << "value=" << to_string(value);
  out << ", " << "hold_time_mseconds="; (__isset.hold_time_mseconds ? (out << to_string(hold_time_mseconds)) : (out << "<null>"));
  out << ", " << "set_if_not_exist="; (__isset.set_if_not_exist ? (out << to_string(set_if_not_exist)) : (out << "<null>"));
  out << ")";
}


redis_hmsetex_filter::~redis_hmsetex_filter() throw() {
}


void redis_hmsetex_filter::__set_field(const std::string& val) {
  this->field = val;
}

void redis_hmsetex_filter::__set_value(const std::string& val) {
  this->value = val;
}

void redis_hmsetex_filter::__set_hold_time_mseconds(const int64_t val) {
  this->hold_time_mseconds = val;
}
std::ostream& operator<<(std::ostream& out, const redis_hmsetex_filter& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t redis_hmsetex_filter::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->field);
          this->__isset.field = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->value);
          this->__isset.value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->hold_time_mseconds);
          this->__isset.hold_time_mseconds = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t redis_hmsetex_filter::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("redis_hmsetex_filter");

  xfer += oprot->writeFieldBegin("field", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->field);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("value", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeBinary(this->value);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("hold_time_mseconds", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->hold_time_mseconds);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(redis_hmsetex_filter &a, redis_hmsetex_filter &b) {
  using ::std::swap;
  swap(a.field, b.field);
  swap(a.value, b.value);
  swap(a.hold_time_mseconds, b.hold_time_mseconds);
  swap(a.__isset, b.__isset);
}

redis_hmsetex_filter::redis_hmsetex_filter(const redis_hmsetex_filter& other49) {
  field = other49.field;
  value = other49.value;
  hold_time_mseconds = other49.hold_time_mseconds;
  __isset = other49.__isset;
}
redis_hmsetex_filter& redis_hmsetex_filter::operator=(const redis_hmsetex_filter& other50) {
  field = other50.field;
  value = other50.value;
  hold_time_mseconds = other50.hold_time_mseconds;
  __isset = other50.__isset;
  return *this;
}
void redis_hmsetex_filter::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "redis_hmsetex_filter(";
  out << "field=" << to_string(field);
  out << ", " << "value=" << to_string(value);
  out << ", " << "hold_time_mseconds=" << to_string(hold_time_mseconds);
  out << ")";
}


region::~region() throw() {
}


void region::__set_country(const std::string& val) {
  this->country = val;
}

void region::__set_area(const std::string& val) {
  this->area = val;
}

void region::__set_master_id(const std::string& val) {
  this->master_id = val;
}

void region::__set_slave_id(const std::string& val) {
  this->slave_id = val;
}
std::ostream& operator<<(std::ostream& out, const region& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t region::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->country);
          this->__isset.country = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->area);
          this->__isset.area = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->master_id);
          this->__isset.master_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->slave_id);
          this->__isset.slave_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t region::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("region");

  xfer += oprot->writeFieldBegin("country", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->country);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("area", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->area);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("master_id", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->master_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("slave_id", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->slave_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(region &a, region &b) {
  using ::std::swap;
  swap(a.country, b.country);
  swap(a.area, b.area);
  swap(a.master_id, b.master_id);
  swap(a.slave_id, b.slave_id);
  swap(a.__isset, b.__isset);
}

region::region(const region& other51) {
  country = other51.country;
  area = other51.area;
  master_id = other51.master_id;
  slave_id = other51.slave_id;
  __isset = other51.__isset;
}
region& region::operator=(const region& other52) {
  country = other52.country;
  area = other52.area;
  master_id = other52.master_id;
  slave_id = other52.slave_id;
  __isset = other52.__isset;
  return *this;
}
void region::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "region(";
  out << "country=" << to_string(country);
  out << ", " << "area=" << to_string(area);
  out << ", " << "master_id=" << to_string(master_id);
  out << ", " << "slave_id=" << to_string(slave_id);
  out << ")";
}


region_filter::~region_filter() throw() {
}


void region_filter::__set_version(const int64_t val) {
  this->version = val;
}
std::ostream& operator<<(std::ostream& out, const region_filter& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t region_filter::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->version);
          this->__isset.version = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t region_filter::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("region_filter");

  xfer += oprot->writeFieldBegin("version", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->version);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(region_filter &a, region_filter &b) {
  using ::std::swap;
  swap(a.version, b.version);
  swap(a.__isset, b.__isset);
}

region_filter::region_filter(const region_filter& other53) {
  version = other53.version;
  __isset = other53.__isset;
}
region_filter& region_filter::operator=(const region_filter& other54) {
  version = other54.version;
  __isset = other54.__isset;
  return *this;
}
void region_filter::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "region_filter(";
  out << "version=" << to_string(version);
  out << ")";
}


region_out::~region_out() throw() {
}


void region_out::__set_reg(const region& val) {
  this->reg = val;
}

void region_out::__set_version(const int64_t val) {
  this->version = val;
}
std::ostream& operator<<(std::ostream& out, const region_out& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t region_out::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->reg.read(iprot);
          this->__isset.reg = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->version);
          this->__isset.version = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t region_out::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("region_out");

  xfer += oprot->writeFieldBegin("reg", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->reg.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("version", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->version);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(region_out &a, region_out &b) {
  using ::std::swap;
  swap(a.reg, b.reg);
  swap(a.version, b.version);
  swap(a.__isset, b.__isset);
}

region_out::region_out(const region_out& other55) {
  reg = other55.reg;
  version = other55.version;
  __isset = other55.__isset;
}
region_out& region_out::operator=(const region_out& other56) {
  reg = other56.reg;
  version = other56.version;
  __isset = other56.__isset;
  return *this;
}
void region_out::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "region_out(";
  out << "reg=" << to_string(reg);
  out << ", " << "version=" << to_string(version);
  out << ")";
}

}}}} // namespace
